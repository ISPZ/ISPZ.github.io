<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>frp内网穿透方法</title>
    <link href="/2020/07/09/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%96%B9%E6%B3%95/"/>
    <url>/2020/07/09/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1>0.准备工作</h1><p>🔔 远端主机（内网主机，客户端）<br>🔔个人电脑（外网设备）<br>🔔frp工具 <a href="https://github.com/fatedier/frp" target="_blank" rel="noopener">https://github.com/fatedier/frp</a><br>🔔跳板主机（云服务器，或者有公网ip的电脑，服务器端）</p><a id="more"></a><h1>1.跳板主机（服务器端）配置</h1><p>以下内容 可以参考b站配置<a href="https://www.bilibili.com/video/BV1J74117714?from=search&amp;seid=147161387819246768" target="_blank" rel="noopener">视频</a></p><h2 id="1-1-购买云服务器"><a class="header-anchor" href="#1-1-购买云服务器">¶</a>1.1 购买云服务器</h2><p>本次使用的是阿里云服务器，阿里称为ECS。</p><p>可以先申请阿里云的账号，购买一般配置即可，这里选用的是： CPU 1核 内存 2G 带宽 1Mbps<br>买好登录到后台，查看概览可以看到有创建好的实例<br><img src="01alpage.png" srcset="/img/loading.gif" alt=""><br>可以看到有公网ip和私网ip，私网ip不管</p><h2 id="1-2-建立ssh连接"><a class="header-anchor" href="#1-2-建立ssh连接">¶</a>1.2 建立SSH连接</h2><p>阿里云服务器连接比较麻烦，需要创建秘钥对</p><ol><li>点击页面左侧 网络与安全–&gt;密钥对<br><img src="02ssh.png" srcset="/img/loading.gif" alt=""></li><li>确保所选位置和服务器所在位置一致<br><img src="03confirm.png" srcset="/img/loading.gif" alt=""></li><li>点击右上角，创建密钥对，输入名称和保存组。其他的先不管<br><img src="04safe.png" srcset="/img/loading.gif" alt=""></li><li>创建完成后选择保存.pem文件到本地</li><li>重启服务器（点击左侧实例与镜像–&gt;实例 在对应的实例下点击 更多–&gt;实例状态–&gt;重启）</li><li>使用SSH工具对服务器进行连接，IP地址输入 公网ip 端口默认22；本文使用MobaXterm连接，在建立新的SSH时将私人密钥打钩，选择之前保存的.pem文件<br><img src="05key.png" srcset="/img/loading.gif" alt=""><br>登录成功后图示如下：<br><img src="06login.png" srcset="/img/loading.gif" alt=""></li></ol><h2 id="1-3-下载配置frp"><a class="header-anchor" href="#1-3-下载配置frp">¶</a>1.3 下载配置FRP</h2><p><a href="https://github.com/fatedier/frp/blob/master/README_zh.md" target="_blank" rel="noopener">frp中文说明书</a></p><ol><li><p>在releases界面找到需要的<a href="https://github.com/fatedier/frp/releases" target="_blank" rel="noopener">版本</a><br><img src="07releases.png" srcset="/img/loading.gif" alt=""><br>本文的跳板机器是64位linux，选择对应的版本下载</p></li><li><p>将下载好的frp上传到跳板机器目录中解压</p><p><img src="08frp.png" srcset="/img/loading.gif" alt=""><br>其中frpc开头的文件都表示客户端使用，即内网服务器。<br>frps开头的文件表示服务器使用，即跳板机器。</p></li><li><p>打开frps.ini文件<br><img src="09frps.png" srcset="/img/loading.gif" alt=""><br>默认配置的端口为7000，token为明文密码，按照自己的喜好设置</p></li></ol><p class="note note-primary">不要设置为自己常用的密码</p><ol start="4"><li><p>回到窗口，进入到frp解压目录，输入命令</p><blockquote><p>./frps -c frps.ini</p></blockquote><p><img src="10frpssuccess.png" srcset="/img/loading.gif" alt=""><br>成功运行</p></li><li><p>打开7000端口<br>进入云服务器后台，点击左侧安全组，在列表中选择配置规则<br><img src="11safegroup.png" srcset="/img/loading.gif" alt=""><br>进入后点击手动添加，输入以下信息，只修改红圈处的内容，其他地方保持不变<br><img src="12group.png" srcset="/img/loading.gif" alt=""><br>到这里云服务器的服务器端配置完成了。</p></li></ol><h3 id="另外可以设置云服务器后端自动运行"><a class="header-anchor" href="#另外可以设置云服务器后端自动运行">¶</a>另外可以设置云服务器后端自动运行</h3><p>a.服务器端输入代码</p><blockquote><p>vi /lib/systemd/system/frps.service</p></blockquote><p><img src="13frpback.png" srcset="/img/loading.gif" alt=""><br>代码段如下</p><pre><code class="hljs plain">[Unit]Description=fraps serviceAfter=network.target syslog.targetWants=network.target[Service]Type=simpleExecStart=/etc/frp/frp/frps -c /etc/frp/frp/frps.ini  #此处安实际情况修改[Install]WantedBy=multi-user.target</code></pre><p>b. 回到命令窗口，输入命令</p><pre><code class="hljs plain">systemctl start frps</code></pre><p>如果希望服务开机自启，则输入命令</p><pre><code class="hljs plain">systemctl enable frps</code></pre><p>c. 查看程序是否运行成功<br>输入命令：</p><pre><code class="hljs plain">ps auxw</code></pre><p><img src="14success.png" srcset="/img/loading.gif" alt=""><br>可以看到程序正常运行</p><h1>2.内网主机（客户端）配置</h1><p>下载方式同上，选择对应的frp版本，这里使用的也是64位linux版本，解压到客户端主机，这里存的位置是</p><blockquote><p>/etc/frp/</p></blockquote><p><img src="15frpclocation.png" srcset="/img/loading.gif" alt=""></p><p>打开frpc.ini文件，设置对应的映射端口<br><img src="16frpc.png" srcset="/img/loading.gif" alt=""></p><p>在命令行端口输入命令：</p><pre><code class="hljs plain">frpc -c frpc.ini</code></pre><p><img src="17frpcsuccess.png" srcset="/img/loading.gif" alt=""><br>运行成功</p><h1>3.SSH工具连接</h1><p>打开MobaXterm新建session<br>输入IP地址，用户名，端口号<br><img src="18sshlink.png" srcset="/img/loading.gif" alt=""><br>输入完成，点击确定<br><img src="19complete.png" srcset="/img/loading.gif" alt=""><br>连接完成</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
    
    <tags>
      
      <tag>FRP内网穿透</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RCNN家族：从RCNN到MSRCNN</title>
    <link href="/2019/12/02/%E4%BB%8ERCNN%E5%88%B0MSRCNN/"/>
    <url>/2019/12/02/%E4%BB%8ERCNN%E5%88%B0MSRCNN/</url>
    
    <content type="html"><![CDATA[<h1><i class="iconfont icon-Batteryempty" style="color: #0095F2;font-size: 35px"></i> 1. CNN简介</h1><p>本文将从RCNN开始，对RCNN家族的目标检测算法进行阐述，包括 RCNN，Fast RCNN，Faster RCNN，Mask RCNN 以及 Mask Score RCNN</p><a id="more"></a><p>CNN（卷积神经网络）作为目前重要的特征提取方法，通过将原图像经过卷积、池化等操作提取图像区域特征，将此特征作为后续图像处理的基础。以文章[<a href="https://mp.weixin.qq.com/s?__biz=MzI3ODkxODU3Mg==&amp;mid=2247487716&amp;idx=1&amp;sn=c4f177cfb8821507b994fc2782fba862&amp;chksm=eb4ef427dc397d3172d1819b869915bfdfddfb044ae1e7771fec04c81532dd8e31fc9f3f1372&amp;scene=7&amp;key=2c47b7dacab9755e60ac90b7a064183ad2e7fadf4cbe81f8f55c0ab8bb40c17b91a90bb61fbda3f274ed1ea3ada8a4edae9ffd71f3c2c8ec12c82f45ddfb13751b3f843e6e98862790e10e924e45ad5e&amp;ascene=0&amp;uin=Mjc3NzMyMDQyNA%3D%3D&amp;devicetype=Windows+10&amp;version=62070158&amp;lang=zh_CN&amp;pass_ticket=kRQCPSOxWsUeFVfu42R1DL7gbOQ0KKXb%2BFiRylVnkfKhPsh1E11iLpxAgPQXGChV" target="_blank" rel="noopener">1</a>]中举出的目标检测方法为例</p><ol><li>输入原图像<br><img src="01src-image.webp" srcset="/img/loading.gif" alt=""></li><li>将原图像分块:<br><img src="02block-image.webp" srcset="/img/loading.gif" alt=""></li><li>将每个区域看作单独的图片。</li><li>把这些区域照片传递给CNN，将它们分到不同类别中。</li><li>当我们把每个区域都分到对应的类别后，再把它们结合在一起，完成对原始图像的目标检测：<br><img src="03block-detection.webp" srcset="/img/loading.gif" alt=""></li></ol><p><font color="#DC143C "> <strong>使用这一方法的问题在于，图片中的物体可能有不同的长宽比和空间位置。例如，在有些情况下，目标物体可能占据了图片的大部分，或者非常小。目标物体的形状也可能不同。</strong></font></p><p>有了这些考虑因素，我们就需要分割很多个区域，需要大量计算力。所以为了解决这一问题，减少区域的分割，我们可以使用基于区域的CNN，它可以进行区域选择</p><!-- <p style="font-family: Times, TimesNR, 'New Century Schoolbook', Georgia, 'New York', serif; color:#0095F2;font-size:1em;font-weight:bold">有了这些考虑因素，我们就需要分割很多个区域，需要大量计算力。所以为了解决这一问题，减少区域的分割，我们可以使用基于区域的CNN，它可以进行区域选择。</p>  --><h1><i class="fas fa-battery-quarter" style="color: #0095F2;font-size: 35px"></i> 2. RCNN</h1><h2 id="2-1-rcnn简介"><a class="header-anchor" href="#2-1-rcnn简介">¶</a>2.1 RCNN简介</h2><p>RCNN算法提出在图像中创建多个边界框，检查这些边框中是否含有目标物体。RCNN使用选择性搜索来从一张图片中提取这些边框。</p><blockquote><p>这里感觉和滑动窗口的方法类似</p></blockquote><p>首先，明确什么是选择性搜索，以及它是如何辨别不同区域的。组成目标物体通常有<font color="#DC143C"><strong>四个要素：变化尺度、颜色、结构（材质）、所占面积。</strong></font>选择性搜索会确定物体在图片中的这些特征，然后基于这些特征突出不同区域。</p><p>下面是选择搜索的一个简单案例：</p><table><thead><tr><th style="text-align:center"><img src="04RCNN-src.webp" srcset="/img/loading.gif" alt=""></th><th style="text-align:center"><img src="05RCNN-sub.webp" srcset="/img/loading.gif" alt=""></th><th style="text-align:center"><img src="06RCNN-sub-optimization.webp" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td style="text-align:center"><strong>将一张图片作为输入</strong></td><td style="text-align:center"><strong>生成最初的区域分割（sub-segmentations），<br>将图片分为多个区域</strong></td><td style="text-align:center"><strong>基于颜色、结构、尺寸、形状等，<br>将相似的区域合并成更大的区域</strong></td></tr></tbody></table><p><strong>最后，</strong> 生成最终的目标物体位置（Region of Interest）</p><!-- <span style="font-size: 35px">Emoji :blush:</span>--><p>总结下来,RCNN检测目标物体的步骤如下：<br><span style="font-size: 23px">1️⃣</span>选取一个预训练卷积神经网络。<br><span style="font-size: 23px">2️⃣</span> 根据需要检测目标类别数量，训练网络的最后一层。<br><span style="font-size: 23px">3️⃣</span> 得到每张图像的感兴趣区域（ Region of Interest），将感兴趣区域变为同样的大小送入到CNN中<br><span style="font-size: 23px">4️⃣</span> 得到感兴趣区域后，训练SVM分类目标和背景区域。对每一类都训练一个二分类SVM<br><span style="font-size: 23px">5️⃣</span> 最后，训练一个线性回归模型，对图像中的每个识别物体生成一个包围盒（bounding boxes）</p><p>使用具体案例进行分析：</p><ul><li><p>首先输入原图像<br><img src="07RCNN-input.png" srcset="/img/loading.gif" alt=""></p></li><li><p>提取感兴趣区域（ROI），使用候选算法（proposal method）如：上述提到的选择搜索（selective search）<br><img src="08rcnn-search.png" srcset="/img/loading.gif" alt=""></p></li><li><p>对每个提取的区域进行形状重塑（reshaped ）为大小一样的图像，送入到相同的卷积网络中<br><img src="09rcnn-extract-feature.png" srcset="/img/loading.gif" alt=""></p></li><li><p>卷积神经网络对每个区域提取的特征，并使用SVM对每个区域进行分类<br><img src="10rcnn-svm.png" srcset="/img/loading.gif" alt=""></p></li><li><p>最后，对每个识别的区域进行边框回归/包围盒回归（bounding box regression，Bbox reg）<br><img src="11rcnn-bbox.png" srcset="/img/loading.gif" alt=""></p></li><li><p>简言之，上述就是RCNN检测的方法。</p></li></ul><h2 id="2-2-rcnn存在的问题"><a class="header-anchor" href="#2-2-rcnn存在的问题">¶</a>2.2 RCNN存在的问题</h2><p>训练RCNN模型非常复杂，并且步骤较多</p><ul><li>根据选择性搜索，可能需要对每张图像提取2000个单独的区域。</li><li>用CNN提取每个区域的特征。假设有N张图片，那么CNN提取特征的数量就是N * 2000 ；</li><li>使用RCNN进行目标检测需要经过三个步骤：<ol><li>CNN特征提取</li><li>使用线性分类器SVM识别</li><li>使用回归模型生成紧凑的包围盒</li></ol></li></ul><p><span style="font-size: 25px">🔎</span> 上述的处理方法使得RCNN的处理速度非常慢。每处理一张新的图片需要40~50秒，这使得整个模型非常的笨重，几乎不可能处理大型数据集。</p><p><span style="font-size: 25px"> 🔧</span> 为了解决上述问题所带来的限制，提出了一种新的目标检测方法。</p><h1><i class="fas fa-battery-half" style="color: #0095F2;font-size: 35px"></i> 3. Fast RCNN</h1><h2 id="3-1-fast-rcnn简介"><a class="header-anchor" href="#3-1-fast-rcnn简介">¶</a>3.1 Fast RCNN简介</h2><p>想要减少RCNN算法的计算时间，可以用什么方法？我们可不可以在每张图片上只使用一次CNN即可得到全部的重点关注区域呢（regions containing some object），而不是运行2000次。</p><p>RCNN的作者Ross Girshick提出了一种想法，在每张照片上只运行一次CNN，然后找到一种方法在2000个区域中进行计算。在Fast RCNN中，我们将图片输入到CNN中，会相应地生成传统特征映射。利用这些映射，就能提取出感兴趣区域。之后，我们使用一个Rol池化层将所有提出的区域重新修正到合适的尺寸，以输入到完全连接的网络中。</p><p>简要概括上述步骤：<br><span style="font-size: 23px">1️⃣</span>如上述的方法所述，先选择一张图像输入。<br><span style="font-size: 23px">2️⃣</span>图像通过卷积网络生成感兴趣区域<br><span style="font-size: 23px">3️⃣</span>通过ROI池化层对每个感兴趣区域进行操作。之后将每个区域送入到全连接网络中<br><span style="font-size: 23px">4️⃣</span>在送入全连接之后通过softmax层输出类别。同样使用一个线性回归层，输出相对应的边界框。</p><p>所以，和RCNN所需要的三个模型不同，Fast RCNN只用了一个模型就同时实现了区域的特征提取、分类、边界框生成。</p><p>同样适用上述的图片进行讲解：</p><ul><li><p>输入图像<br><img src="12fast-input.png" srcset="/img/loading.gif" alt=""></p></li><li><p>传递到卷积网路中生成相应的感兴趣区域<br><img src="13fast-extract.png" srcset="/img/loading.gif" alt=""></p></li><li><p>适用ROI池化层将每个感兴趣区域设置为同样大小<br><img src="14fast-roipooling.png" srcset="/img/loading.gif" alt=""></p></li><li><p>最后，将这些区域送入到全连接层进行分类，同时使用softmax和线性回归来预测边界框<br><img src="15fast-classification.png" srcset="/img/loading.gif" alt=""></p></li></ul><p>上述过程就表明了Fast RCNN如何让解决RCNN主要问题的方法。<font color="#DC143C"><strong>通过一个卷积网络代替2000个卷积网络；使用一个模块代替RCNN中的特征提取，分类和生成包围盒三个模块。</strong></font></p><h2 id="3-2-fast-rcnn所存在的问题"><a class="header-anchor" href="#3-2-fast-rcnn所存在的问题">¶</a>3.2 Fast RCNN所存在的问题</h2><p><span style="font-size: 25px">🔎</span> 尽管如此，Fast RCNN仍然存在一些问题。它仍然使用选择性搜索方法寻找感兴趣区域。这种处理方法仍然很慢，与RCNN不同的是，Fast RCNN处理一张图片大约需要2秒。但是在大型真实数据集上，这种速度仍然不够理想。</p><p><span style="font-size: 25px"> 🔧</span> 为了解决搜索缓慢的问题，提出另一种胜过Fast RCNN的目标检测算法</p><h1><i class="fas fa-battery-three-quarters" style="color: #0095F2;font-size: 35px"></i> 4. Faster RCNN</h1><h2 id="4-1-faster-rcnn简介"><a class="header-anchor" href="#4-1-faster-rcnn简介">¶</a>4.1 Faster RCNN简介</h2><p>Faster RCNN是Fast RCNN的优化版本，二者主要的不同在于感兴趣区域的生成方法，Fast RCNN使用的是选择性搜索，而Faster RCNN用的是Region Proposal网络（RPN/候选区域网络）。RPN将图像特征映射作为输入，生成一系列object proposals，每个都带有相应的分数。</p><p>下面是Faster RCNN的处理过程：<br><span style="font-size: 23px">1️⃣</span> 输入图像到卷积网络中，生成该图像的特征映射；<br><span style="font-size: 23px">2️⃣</span> 在特征映射上应用RPN，返回候选物体（object proposals）和相应的分数 🔔<br><span style="font-size: 23px">3️⃣</span> 应用ROI池化层，将所有的proposals修正到同样的尺寸。<br><span style="font-size: 23px">4️⃣</span> 最后，将proposals送入到全连接层，并使用softmax和线性回归层来输出目标物体的包围盒。</p><p>Faster RCNN中的重要改进部分是RPN网路，总体的处理流程简化如下图：<br><img src="16faster.png" srcset="/img/loading.gif" alt=""></p><p>那么Region Proposal Network具体是如何工作的呢？首先，将CNN中得来的特征映射输入到Faster RCNN中，然后将其传递到Region Proposal Network中。RPN会在这些特征映射上使用一个滑动窗口，每个窗口会生成具有不同形状和尺寸的k个anchor box：<br><img src="17anchor.png" srcset="/img/loading.gif" alt=""></p><p>Anchor boxes是固定尺寸的边界框，它们有不同的形状和大小。对每个anchor，RPN都会预测两点：</p><ul><li>首先是anchor就是目标物体的概率（不考虑类别）</li><li>anchor经过调整能更合适目标物体的边界框回归量</li></ul><p>现在我们有了不同形状、尺寸的边界框，将它们传递到Rol池化层中。经过RPN的处理，proposals可能没有所述的类别。我们可以对每个proposal进行切割，让它们都含有目标物体。这就是Rol池化层的作用。它为每个anchor提取固定尺寸的特征映射<br><img src="18roi.png" srcset="/img/loading.gif" alt=""></p><div style="text-align:center"> ROI分类 </div>之后，这些特征映射会传递到完全连接层，对目标进行分类并预测边界框。<h2 id="4-2-faster-rcnn详解"><a class="header-anchor" href="#4-2-faster-rcnn详解">¶</a>4.2 Faster RCNN详解</h2><p>具体完整细节可参考文章 <a href="https://zhuanlan.zhihu.com/p/31426458" target="_blank" rel="noopener">(2)</a>，其将Faster RCNN分为4个部分：</p><ol><li>卷积层（Conv layers）：Faster RCNN首先使用一组基础的conv+relu+pooling层提取image的feature maps。该feature maps被共享用于后续RPN层和全连接层。</li><li>候选区域网络(Region Proposal Networks , RPN)：RPN网络用于生成候选区域。该层通过softmax判断anchers属于positive或者negative，再利用包围盒回归（bounding box regression）修正anchors,获得精确的预测。</li><li>感兴趣区域池化（ROI Pooling）：该层收集输入的feature maps和proposals，综合这些信息后提取proposal feature maps，送入后续全连接层判定目标类别。</li><li>分类（classification）：利用proposal feature maps计算proposal的类别，同时再次bounding box regression获得检测框最终的精确位置。</li></ol><p>摘取文章中对RPN网络的详解（其他部分参照文章<a href="https://zhuanlan.zhihu.com/p/31426458" target="_blank" rel="noopener">(2)</a>）：</p><p>先给出faster_rcnn_test的网络结构：</p><p><img src="19fasterrcnn.jpg" srcset="/img/loading.gif" alt="19fasterrcnn"></p><div style="text-align:center"> faster_rcnn_test.pt网络结构 </div>RPN网络的结构：<p><img src="20faster-rpn.jpg" srcset="/img/loading.gif" alt="20faster-rpn"></p><div style="text-align:center"> RPN网络结构 </div><p>🔔 RPN网络实际分为2条线，<strong>上路径</strong>通过softmax分类anchors获得positive和negative分类，<strong>下路径</strong>用于计算对于anchors的bounding box regression偏移量，以获得精确的proposal。</p><p>🔔 而最后的Proposal层则负责综合positive anchors和对应bounding box regression偏移量获取proposals，同时剔除太小和超出边界的proposals。</p><p>🔔 其实整个网络到了Proposal Layer这里，就完成了相当于目标定位的功能。</p><h1><i class="fas fa-battery-full" style="color: #0095F2;font-size: 35px"></i> 5. Mask RCNN</h1><!--<i class="fas fa-battery-bolt" style="color: #0095F2;font-size: 35px"></i>--><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
    <categories>
      
      <category>DL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
      <tag>神经网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo安装及Github部署</title>
    <link href="/2019/11/18/Hexo%E5%AE%89%E8%A3%85%E5%8F%8AGithub%E9%83%A8%E7%BD%B2/"/>
    <url>/2019/11/18/Hexo%E5%AE%89%E8%A3%85%E5%8F%8AGithub%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<h1>预备工作</h1><h2 id="安装git"><a class="header-anchor" href="#安装git">¶</a>安装git</h2><p>从<a href="https://git-scm.com/" target="_blank" rel="noopener"><i class="fab fa-git"></i>官网</a>下载符合自己系统的版本</p><a id="more"></a><p>本文不再详细阐述Git的安装方法，可以按照<a href="https://www.runoob.com/git/git-install-setup.html" target="_blank" rel="noopener">菜鸟教程<i class="fas fa-share-square"></i></a>或者<a href="https://www.liaoxuefeng.com/wiki/896043488029600/896067074338496" target="_blank" rel="noopener">廖雪峰<i class="fas fa-share-square"></i></a>的教程进行安装。</p><h2 id="安装node-js"><a class="header-anchor" href="#安装node-js">¶</a>安装node.js</h2><p>从<a href="https://nodejs.org/en/" target="_blank" rel="noopener">官网<i class="fab fa-node-js"></i></a>下载<br>选择下载长期支持版本</p><img src="/2019/11/18/Hexo%E5%AE%89%E8%A3%85%E5%8F%8AGithub%E9%83%A8%E7%BD%B2/nodejs.png" srcset="/img/loading.gif" class="" title="spaced title"><p>下载安装完成后会安装两个工具，分别是node和npm。按下win+R输入powershell，验证下载是否成功</p><pre><code class="hljs plain">node -vnpm -v</code></pre><p>输出结果如下图所示：<br><img src="00_instal_cnpm.png" srcset="/img/loading.gif" alt="install cnpm"></p><h2 id="安装cnpm"><a class="header-anchor" href="#安装cnpm">¶</a>安装cnpm</h2><p>由于npm的下载速度缓慢，所以需要将安装国内镜像cnpm，仓库为<a href="https://npm.taobao.org/" target="_blank" rel="noopener">淘宝仓库<i class="fab fa-npm"></i></a></p><pre><code class="hljs plain">npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre><p>等待安装完成，输入</p><pre><code class="hljs plain">cnpm -v</code></pre><p>检验安装是否成功</p><h1>安装Hexo</h1><h2 id="hexo初始化"><a class="header-anchor" href="#hexo初始化">¶</a>hexo初始化</h2><p>在本地电脑中创建文件夹用来存储博客内容</p><pre><code class="hljs plain">D:\00 DATA\08 HEXO blog\blog</code></pre><p>在powershell中进入当前文件夹，输入代码安装hexo</p><pre><code class="hljs plain">cnpm install -g hexo-cli</code></pre><p>等待安装完成，安装完成后显示如下：<br><img src="01_install_hexo.png" srcset="/img/loading.gif" alt=""></p><p>输入</p><pre><code class="hljs plain">hexo -v</code></pre><p>检测hexo是否安装成功。<br><img src="02_validation_hexo.png" srcset="/img/loading.gif" alt=""><br>如上图就代表安装成功</p><h2 id="hexo初始化及本地预览"><a class="header-anchor" href="#hexo初始化及本地预览">¶</a>hexo初始化及本地预览</h2><p>完成hexo安装后，需要实现hexo初始化，并生成样例博客。在blog的文件夹下输入</p><pre><code class="hljs plain">hexo init</code></pre><p>如果没有更改host，github下载速度较慢需要等待2分钟左右，若未报错则安装成功。安装成功后输入指令</p><pre><code class="hljs plain">hexo s</code></pre><p>可以在 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 进行预览。</p><h2 id="hexo建立新博客"><a class="header-anchor" href="#hexo建立新博客">¶</a>hexo建立新博客</h2><p>在完成上述的初始化工作之后，可以建立自己的第一篇文章。输入命令：</p><pre><code class="hljs plain">hexo n "我的第一篇hexo博客"</code></pre><p>双引号中的内容为博客名字，其存储位置在</p><blockquote><p>.\source_posts</p></blockquote><p>查看博客的保存位置<br><img src="07_set_first_artical.png" srcset="/img/loading.gif" alt=""><br>有生成的.md文件，对.md文件使用markdown进行编辑，保存（这里不再详细说明.md文件的编辑方法，可以用Typora工具、vim等），在blog文件夹下输入三条指令</p><pre><code class="hljs plain">hexo cleanhexo ghexo s</code></pre><p><img src="08_generate_artical.png" srcset="/img/loading.gif" alt=""><br>可以在 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 端口查看生成效果。</p><h1>部署至<a href="https://github.com/" target="_blank" rel="noopener">GitHub<i class="fab  fa-github"></i></a></h1><h2 id="建立git仓库并安装git插件"><a class="header-anchor" href="#建立git仓库并安装git插件">¶</a>建立Git仓库并安装Git插件</h2><p>在自己的github账户下建立一个repository输入名字，这里需要注意你的repository名字必须是 <strong>[账户名].github.io</strong><br>安装git插件，在power客户端下输入指令：</p><pre><code class="hljs plain">cnpm install --save hexo-deployer-git</code></pre><p>安装成功，提示如下：<br><img src="09_install_git_plugin.png" srcset="/img/loading.gif" alt=""></p><h2 id="设置配置文件"><a class="header-anchor" href="#设置配置文件">¶</a>设置配置文件</h2><p>部署到github远端需要修改hexo文件下的 _config.yml 文件，打开文件找到deploy位置<br><img src="10_git_set_position.png" srcset="/img/loading.gif" alt=""><br>修改类型属性(type)，添加两个属性 **repo和 branch **<br><img src="11_edit_repo.png" srcset="/img/loading.gif" alt=""><br>其中repo属性对应git地址，branch对应分支选项。</p><h2 id="远端部署"><a class="header-anchor" href="#远端部署">¶</a>远端部署</h2><p>修改_config.yml文件完成，需要将本地的博客部署到github上，使用命令</p><pre><code class="hljs plain">hexo d</code></pre><p><img src="12_remote_deploy_hexo.png" srcset="/img/loading.gif" alt=""><br>等待…出现登录页，输入账号密码<br><img src="13_login.png" srcset="/img/loading.gif" alt=""><br>部署完成<br><img src="14_complete.png" srcset="/img/loading.gif" alt=""></p><h1>主题美化</h1><h2 id="主题下载"><a class="header-anchor" href="#主题下载">¶</a>主题下载</h2><p>hexo自带的主题为landspace，主题样式可以更改，这里选择下载yilia主题。在blog文件夹下输入命令：</p><pre><code class="hljs plain">git colne https://github.com/litten/hexo-theme-yilia .\theme\yilia</code></pre><p>其中 网址为下载地址，网址后的路径为主题的存储位置。下载完成如下：<br><img src="15_download_yilia_theme.png" srcset="/img/loading.gif" alt=""><br>进入theme文件夹下，查看主题是否存储完成：<br><img src="16_theme_location.png" srcset="/img/loading.gif" alt=""></p><h2 id="更改主题"><a class="header-anchor" href="#更改主题">¶</a>更改主题</h2><p>下载完成后需要修改blog文件夹下的_config.yml文件，打开找到 <strong>theme</strong>属性<br><img src="17_set_theme.png" srcset="/img/loading.gif" alt=""></p><p>若未更改过主题，则显示为<strong>theme:landspace</strong>, landspace为主题名称，将其修改为 <strong>theme:yilia</strong>，在窗口输入三行指令在本地查看修改情况：</p><pre><code class="hljs plain">hexo cleanhexo ghexo s</code></pre><p>若未出错，可以将其推向github，输入指令 ：</p><pre><code class="hljs plain">hexo d</code></pre><h1>遇到的错误</h1><p>在hexo初始化时遇到一些小错误，输入初始化指令<strong>hexo init</strong>，出现错误结果如下：<br><img src="04_hexo_init_error.png" srcset="/img/loading.gif" alt=""></p><p>按照错误提示输入 <strong>npm install</strong> 仍报错<br><img src="05_input_npm_install_still_error.png" srcset="/img/loading.gif" alt=""></p><p>考虑到可能是连不上服务器所导致的，所以选择输入指令<strong>cnpm install</strong><br><img src="06_input_cnpm_install_solve_the_problem.png" srcset="/img/loading.gif" alt=""><br>问题解决</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo的安装使用及Github部署</title>
    <link href="/2019/11/17/Hexo%E5%8D%9A%E5%AE%A2%E7%BC%96%E5%86%99%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <url>/2019/11/17/Hexo%E5%8D%9A%E5%AE%A2%E7%BC%96%E5%86%99%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p><font color="#DC143C ">  <strong>本文用来不定时更新</strong> </font></p><a id="more"></a><h1>文档加载图片</h1><h2 id="markdown语法加载"><a class="header-anchor" href="#markdown语法加载">¶</a>markdown语法加载</h2><ol><li>找到hexo下的 _config.yml 文件，本机的存储位置</li></ol><pre><code class="hljs plain">D:\00 DATA\08 HEXO blog\blog\ _config.yml</code></pre><ol start="2"><li>找到 post_asset_folder 属性，将其改为 true</li></ol><pre><code class="hljs plain">post_asset_folder: true</code></pre><ol start="3"><li>使用指令</li></ol><pre><code class="hljs plain">hexo n "博客文章的名字"</code></pre><p>新建一个博客，在路径</p><pre><code class="hljs plain">\source\_posts</code></pre><p>下生成两个文件，分别为.md文件和其同名文件夹，将需要放在文章中的图片拷贝在同名文件夹中</p><ol start="4"><li>在.md文件中使用以下代码添加图片</li></ol><pre><code class="hljs markdown">![<span class="hljs-string">图片描述</span>](<span class="hljs-link">图片名称</span>)</code></pre><p>上述的图片名称 可以直接写出图片的名称及类型，在文章中就可以正常显示。</p><h2 id="官方加载"><a class="header-anchor" href="#官方加载">¶</a>官方加载</h2><p>markdown语法加载图像的方式，在博客首页无法正常显示。所以这里给出另一种加载图像的方式，来解决上述问题。<br><a href="https://hexo.io/zh-cn/docs/asset-folders" target="_blank" rel="noopener">官网文档</a>给出的标签插件方法加载图片，仍按照上述1~3步骤来配置，第4部在编写.md文件时，插入图像语法修改为：</p><pre><code class="hljs plain">{% asset_img 图像名.图像类型 图像名称 %}</code></pre><p>上述的加载方式在博客首页和文章内部都可以正常显示。</p><h1>修改博客背景</h1><p>修改文件 post.styl,存储位置</p><blockquote><p>D:\00 DATA\08 HEXO blog\blog\themes\next\source\css_common\components\post\post.styl</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
