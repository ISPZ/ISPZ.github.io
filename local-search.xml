<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>RCNN家族：从RCNN到MSRCNN</title>
    <link href="undefined2019/12/02/%E4%BB%8ERCNN%E5%88%B0MSRCNN/"/>
    <url>2019/12/02/%E4%BB%8ERCNN%E5%88%B0MSRCNN/</url>
    
    <content type="html"><![CDATA[<h1><i class="fas fa-battery-empty" style="color: #0095F2;font-size: 35px"></i> 1. CNN简介</h1><p>本文将从RCNN开始，对RCNN家族的目标检测算法进行阐述，包括 RCNN，Fast RCNN，Faster RCNN，Mask RCNN 以及 Mask Score RCNN</p><a id="more"></a><p>CNN（卷积神经网络）作为目前重要的特征提取方法，通过将原图像经过卷积、池化等操作提取图像区域特征，将此特征作为后续图像处理的基础。以文章[<a href="https://mp.weixin.qq.com/s?__biz=MzI3ODkxODU3Mg==&amp;mid=2247487716&amp;idx=1&amp;sn=c4f177cfb8821507b994fc2782fba862&amp;chksm=eb4ef427dc397d3172d1819b869915bfdfddfb044ae1e7771fec04c81532dd8e31fc9f3f1372&amp;scene=7&amp;key=2c47b7dacab9755e60ac90b7a064183ad2e7fadf4cbe81f8f55c0ab8bb40c17b91a90bb61fbda3f274ed1ea3ada8a4edae9ffd71f3c2c8ec12c82f45ddfb13751b3f843e6e98862790e10e924e45ad5e&amp;ascene=0&amp;uin=Mjc3NzMyMDQyNA%3D%3D&amp;devicetype=Windows+10&amp;version=62070158&amp;lang=zh_CN&amp;pass_ticket=kRQCPSOxWsUeFVfu42R1DL7gbOQ0KKXb%2BFiRylVnkfKhPsh1E11iLpxAgPQXGChV" target="_blank" rel="noopener">1</a>]中举出的目标检测方法为例</p><ol><li>输入原图像<br><img src="01src-image.webp" srcset="/img/loading.gif" alt=""></li><li>将原图像分块:<br><img src="02block-image.webp" srcset="/img/loading.gif" alt=""></li><li>将每个区域看作单独的图片。</li><li>把这些区域照片传递给CNN，将它们分到不同类别中。</li><li>当我们把每个区域都分到对应的类别后，再把它们结合在一起，完成对原始图像的目标检测：<br><img src="03block-detection.webp" srcset="/img/loading.gif" alt=""></li></ol><p><font color="#DC143C "> <strong>使用这一方法的问题在于，图片中的物体可能有不同的长宽比和空间位置。例如，在有些情况下，目标物体可能占据了图片的大部分，或者非常小。目标物体的形状也可能不同。</strong></font></p><p>有了这些考虑因素，我们就需要分割很多个区域，需要大量计算力。所以为了解决这一问题，减少区域的分割，我们可以使用基于区域的CNN，它可以进行区域选择</p><!-- <p style="font-family: Times, TimesNR, 'New Century Schoolbook', Georgia, 'New York', serif; color:#0095F2;font-size:1em;font-weight:bold">有了这些考虑因素，我们就需要分割很多个区域，需要大量计算力。所以为了解决这一问题，减少区域的分割，我们可以使用基于区域的CNN，它可以进行区域选择。</p>  --><h1><i class="fas fa-battery-quarter" style="color: #0095F2;font-size: 35px"></i> 2. RCNN</h1><h2 id="2-1-rcnn简介"><a class="header-anchor" href="#2-1-rcnn简介">¶</a>2.1 RCNN简介</h2><p>RCNN算法提出在图像中创建多个边界框，检查这些边框中是否含有目标物体。RCNN使用选择性搜索来从一张图片中提取这些边框。</p><blockquote><p>这里感觉和滑动窗口的方法类似</p></blockquote><p>首先，明确什么是选择性搜索，以及它是如何辨别不同区域的。组成目标物体通常有<font color="#DC143C" ><strong>四个要素：变化尺度、颜色、结构（材质）、所占面积。</strong></font>选择性搜索会确定物体在图片中的这些特征，然后基于这些特征突出不同区域。</p><p>下面是选择搜索的一个简单案例：</p><table><thead><tr><th style="text-align:center"><img src="04RCNN-src.webp" srcset="/img/loading.gif" alt=""></th><th style="text-align:center"><img src="05RCNN-sub.webp" srcset="/img/loading.gif" alt=""></th><th style="text-align:center"><img src="06RCNN-sub-optimization.webp" srcset="/img/loading.gif" alt=""></th></tr></thead><tbody><tr><td style="text-align:center"><strong>将一张图片作为输入</strong></td><td style="text-align:center"><strong>生成最初的区域分割（sub-segmentations），<br>将图片分为多个区域</strong></td><td style="text-align:center"><strong>基于颜色、结构、尺寸、形状等，<br>将相似的区域合并成更大的区域</strong></td></tr></tbody></table><p><strong>最后，</strong> 生成最终的目标物体位置（Region of Interest）</p><!-- <span style="font-size: 35px">Emoji :blush:</span>--><p>总结下来,RCNN检测目标物体的步骤如下：<br><span style="font-size: 23px">1️⃣</span>选取一个预训练卷积神经网络。<br><span style="font-size: 23px">2️⃣</span> 根据需要检测目标类别数量，训练网络的最后一层。<br><span style="font-size: 23px">3️⃣</span> 得到每张图像的感兴趣区域（ Region of Interest），将感兴趣区域变为同样的大小送入到CNN中<br><span style="font-size: 23px">4️⃣</span> 得到感兴趣区域后，训练SVM分类目标和背景区域。对每一类都训练一个二分类SVM<br><span style="font-size: 23px">5️⃣</span> 最后，训练一个线性回归模型，对图像中的每个识别物体生成一个包围盒（bounding boxes）</p><p>使用具体案例进行分析：</p><ul><li><p>首先输入原图像<br><img src="07RCNN-input.png" srcset="/img/loading.gif" alt=""></p></li><li><p>提取感兴趣区域（ROI），使用候选算法（proposal method）如：上述提到的选择搜索（selective search）<br><img src="08rcnn-search.png" srcset="/img/loading.gif" alt=""></p></li><li><p>对每个提取的区域进行形状重塑（reshaped ）为大小一样的图像，送入到相同的卷积网络中<br><img src="09rcnn-extract-feature.png" srcset="/img/loading.gif" alt=""></p></li><li><p>卷积神经网络对每个区域提取的特征，并使用SVM对每个区域进行分类<br><img src="10rcnn-svm.png" srcset="/img/loading.gif" alt=""></p></li><li><p>最后，对每个识别的区域进行边框回归/包围盒回归（bounding box regression，Bbox reg）<br><img src="11rcnn-bbox.png" srcset="/img/loading.gif" alt=""></p></li><li><p>简言之，上述就是RCNN检测的方法。</p></li></ul><h2 id="2-2-rcnn存在的问题"><a class="header-anchor" href="#2-2-rcnn存在的问题">¶</a>2.2 RCNN存在的问题</h2><p>训练RCNN模型非常复杂，并且步骤较多</p><ul><li>根据选择性搜索，可能需要对每张图像提取2000个单独的区域。</li><li>用CNN提取每个区域的特征。假设有N张图片，那么CNN提取特征的数量就是N * 2000 ；</li><li>使用RCNN进行目标检测需要经过三个步骤：<ol><li>CNN特征提取</li><li>使用线性分类器SVM识别</li><li>使用回归模型生成紧凑的包围盒</li></ol></li></ul><p><span style="font-size: 25px">🔎</span> 上述的处理方法使得RCNN的处理速度非常慢。每处理一张新的图片需要40~50秒，这使得整个模型非常的笨重，几乎不可能处理大型数据集。</p><p><span style="font-size: 25px"> 🔧</span> 为了解决上述问题所带来的限制，提出了一种新的目标检测方法。</p><h1><i class="fas fa-battery-half" style="color: #0095F2;font-size: 35px"></i> 3. Fast RCNN</h1><h2 id="3-1-fast-rcnn简介"><a class="header-anchor" href="#3-1-fast-rcnn简介">¶</a>3.1 Fast RCNN简介</h2><p>想要减少RCNN算法的计算时间，可以用什么方法？我们可不可以在每张图片上只使用一次CNN即可得到全部的重点关注区域呢（regions containing some object），而不是运行2000次。</p><p>RCNN的作者Ross Girshick提出了一种想法，在每张照片上只运行一次CNN，然后找到一种方法在2000个区域中进行计算。在Fast RCNN中，我们将图片输入到CNN中，会相应地生成传统特征映射。利用这些映射，就能提取出感兴趣区域。之后，我们使用一个Rol池化层将所有提出的区域重新修正到合适的尺寸，以输入到完全连接的网络中。</p><p>简要概括上述步骤：<br><span style="font-size: 23px">1️⃣</span>如上述的方法所述，先选择一张图像输入。<br><span style="font-size: 23px">2️⃣</span>图像通过卷积网络生成感兴趣区域<br><span style="font-size: 23px">3️⃣</span>通过ROI池化层对每个感兴趣区域进行操作。之后将每个区域送入到全连接网络中<br><span style="font-size: 23px">4️⃣</span>在送入全连接之后通过softmax层输出类别。同样使用一个线性回归层，输出相对应的边界框。</p><p>所以，和RCNN所需要的三个模型不同，Fast RCNN只用了一个模型就同时实现了区域的特征提取、分类、边界框生成。</p><p>同样适用上述的图片进行讲解：</p><ul><li><p>输入图像<br><img src="12fast-input.png" srcset="/img/loading.gif" alt=""></p></li><li><p>传递到卷积网路中生成相应的感兴趣区域<br><img src="13fast-extract.png" srcset="/img/loading.gif" alt=""></p></li><li><p>适用ROI池化层将每个感兴趣区域设置为同样大小<br><img src="14fast-roipooling.png" srcset="/img/loading.gif" alt=""></p></li><li><p>最后，将这些区域送入到全连接层进行分类，同时使用softmax和线性回归来预测边界框<br><img src="15fast-classification.png" srcset="/img/loading.gif" alt=""></p></li></ul><p>上述过程就表明了Fast RCNN如何让解决RCNN主要问题的方法。<font color="#DC143C" ><strong>通过一个卷积网络代替2000个卷积网络；使用一个模块代替RCNN中的特征提取，分类和生成包围盒三个模块。</strong></font></p><h2 id="3-2-fast-rcnn所存在的问题"><a class="header-anchor" href="#3-2-fast-rcnn所存在的问题">¶</a>3.2 Fast RCNN所存在的问题</h2><p><span style="font-size: 25px">🔎</span> 尽管如此，Fast RCNN仍然存在一些问题。它仍然使用选择性搜索方法寻找感兴趣区域。这种处理方法仍然很慢，与RCNN不同的是，Fast RCNN处理一张图片大约需要2秒。但是在大型真实数据集上，这种速度仍然不够理想。</p><p><span style="font-size: 25px"> 🔧</span> 为了解决搜索缓慢的问题，提出另一种胜过Fast RCNN的目标检测算法</p><h1><i class="fas fa-battery-three-quarters" style="color: #0095F2;font-size: 35px"></i> 4. Faster RCNN</h1><h2 id="4-1-faster-rcnn简介"><a class="header-anchor" href="#4-1-faster-rcnn简介">¶</a>4.1 Faster RCNN简介</h2><p>Faster RCNN是Fast RCNN的优化版本，二者主要的不同在于感兴趣区域的生成方法，Fast RCNN使用的是选择性搜索，而Faster RCNN用的是Region Proposal网络（RPN/候选区域网络）。RPN将图像特征映射作为输入，生成一系列object proposals，每个都带有相应的分数。</p><p>下面是Faster RCNN的处理过程：<br><span style="font-size: 23px">1️⃣</span> 输入图像到卷积网络中，生成该图像的特征映射；<br><span style="font-size: 23px">2️⃣</span> 在特征映射上应用RPN，返回候选物体（object proposals）和相应的分数 🔔<br><span style="font-size: 23px">3️⃣</span> 应用ROI池化层，将所有的proposals修正到同样的尺寸。<br><span style="font-size: 23px">4️⃣</span> 最后，将proposals送入到全连接层，并使用softmax和线性回归层来输出目标物体的包围盒。</p><p>Faster RCNN中的重要改进部分是RPN网路，总体的处理流程简化如下图：<br><img src="16faster.png" srcset="/img/loading.gif" alt=""></p><p>那么Region Proposal Network具体是如何工作的呢？首先，将CNN中得来的特征映射输入到Faster RCNN中，然后将其传递到Region Proposal Network中。RPN会在这些特征映射上使用一个滑动窗口，每个窗口会生成具有不同形状和尺寸的k个anchor box：<br><img src="17anchor.png" srcset="/img/loading.gif" alt=""></p><p>Anchor boxes是固定尺寸的边界框，它们有不同的形状和大小。对每个anchor，RPN都会预测两点：</p><ul><li>首先是anchor就是目标物体的概率（不考虑类别）</li><li>anchor经过调整能更合适目标物体的边界框回归量</li></ul><p>现在我们有了不同形状、尺寸的边界框，将它们传递到Rol池化层中。经过RPN的处理，proposals可能没有所述的类别。我们可以对每个proposal进行切割，让它们都含有目标物体。这就是Rol池化层的作用。它为每个anchor提取固定尺寸的特征映射<br><img src="18roi.png" srcset="/img/loading.gif" alt=""></p><div style="text-align:center"> ROI分类 </div>之后，这些特征映射会传递到完全连接层，对目标进行分类并预测边界框。<h2 id="4-2-faster-rcnn详解"><a class="header-anchor" href="#4-2-faster-rcnn详解">¶</a>4.2 Faster RCNN详解</h2><p>具体完整细节可参考文章 <a href="https://zhuanlan.zhihu.com/p/31426458" target="_blank" rel="noopener">(2)</a>，其将Faster RCNN分为4个部分：</p><ol><li>卷积层（Conv layers）：Faster RCNN首先使用一组基础的conv+relu+pooling层提取image的feature maps。该feature maps被共享用于后续RPN层和全连接层。</li><li>候选区域网络(Region Proposal Networks , RPN)：RPN网络用于生成候选区域。该层通过softmax判断anchers属于positive或者negative，再利用包围盒回归（bounding box regression）修正anchors,获得精确的预测。</li><li>感兴趣区域池化（ROI Pooling）：该层收集输入的feature maps和proposals，综合这些信息后提取proposal feature maps，送入后续全连接层判定目标类别。</li><li>分类（classification）：利用proposal feature maps计算proposal的类别，同时再次bounding box regression获得检测框最终的精确位置。</li></ol><p>摘取文章中对RPN网络的详解（其他部分参照文章<a href="https://zhuanlan.zhihu.com/p/31426458" target="_blank" rel="noopener">(2)</a>）：</p><p>先给出faster_rcnn_test的网络结构：</p><p><img src="19fasterrcnn.jpg" srcset="/img/loading.gif" alt="19fasterrcnn"></p><div style="text-align:center"> faster_rcnn_test.pt网络结构 </div>RPN网络的结构：<p><img src="20faster-rpn.jpg" srcset="/img/loading.gif" alt="20faster-rpn"></p><div style="text-align:center"> RPN网络结构 </div><p>🔔 RPN网络实际分为2条线，<strong>上路径</strong>通过softmax分类anchors获得positive和negative分类，<strong>下路径</strong>用于计算对于anchors的bounding box regression偏移量，以获得精确的proposal。</p><p>🔔 而最后的Proposal层则负责综合positive anchors和对应bounding box regression偏移量获取proposals，同时剔除太小和超出边界的proposals。</p><p>🔔 其实整个网络到了Proposal Layer这里，就完成了相当于目标定位的功能。</p><h1><i class="fas fa-battery-full" style="color: #0095F2;font-size: 35px"></i> 5. Mask RCNN</h1><!--<i class="fas fa-battery-bolt" style="color: #0095F2;font-size: 35px"></i>-->]]></content>
    
    
    <categories>
      
      <category>DL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
      <tag>神经网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo安装及Github部署</title>
    <link href="undefined2019/11/18/Hexo%E5%AE%89%E8%A3%85%E5%8F%8AGithub%E9%83%A8%E7%BD%B2/"/>
    <url>2019/11/18/Hexo%E5%AE%89%E8%A3%85%E5%8F%8AGithub%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<h1>预备工作</h1><h2 id="安装git"><a class="header-anchor" href="#安装git">¶</a>安装git</h2><p>从<a href="https://git-scm.com/" target="_blank" rel="noopener"><i class="fab fa-git"></i>官网</a>下载符合自己系统的版本</p><a id="more"></a><p>本文不再详细阐述Git的安装方法，可以按照<a href="https://www.runoob.com/git/git-install-setup.html" target="_blank" rel="noopener">菜鸟教程<i class="fas fa-share-square"></i></a>或者<a href="https://www.liaoxuefeng.com/wiki/896043488029600/896067074338496" target="_blank" rel="noopener">廖雪峰<i class="fas fa-share-square"></i></a>的教程进行安装。</p><h2 id="安装node-js"><a class="header-anchor" href="#安装node-js">¶</a>安装node.js</h2><p>从<a href="https://nodejs.org/en/" target="_blank" rel="noopener">官网<i class="fab fa-node-js"></i></a>下载<br>选择下载长期支持版本</p><img src="/2019/11/18/Hexo%E5%AE%89%E8%A3%85%E5%8F%8AGithub%E9%83%A8%E7%BD%B2/nodejs.png" srcset="/img/loading.gif" class="" title="spaced title"><p>下载安装完成后会安装两个工具，分别是node和npm。按下win+R输入powershell，验证下载是否成功</p><pre><code>node -vnpm -v</code></pre><p>输出结果如下图所示：<br><img src="00_instal_cnpm.png" srcset="/img/loading.gif" alt="install cnpm"></p><h2 id="安装cnpm"><a class="header-anchor" href="#安装cnpm">¶</a>安装cnpm</h2><p>由于npm的下载速度缓慢，所以需要将安装国内镜像cnpm，仓库为<a href="https://npm.taobao.org/" target="_blank" rel="noopener">淘宝仓库<i class="fab fa-npm"></i></a></p><pre><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre><p>等待安装完成，输入</p><pre><code>cnpm -v</code></pre><p>检验安装是否成功</p><h1>安装Hexo</h1><h2 id="hexo初始化"><a class="header-anchor" href="#hexo初始化">¶</a>hexo初始化</h2><p>在本地电脑中创建文件夹用来存储博客内容</p><pre><code>D:\00 DATA\08 HEXO blog\blog </code></pre><p>在powershell中进入当前文件夹，输入代码安装hexo</p><pre><code>cnpm install -g hexo-cli</code></pre><p>等待安装完成，安装完成后显示如下：<br><img src="01_install_hexo.png" srcset="/img/loading.gif" alt=""></p><p>输入</p><pre><code>hexo -v </code></pre><p>检测hexo是否安装成功。<br><img src="02_validation_hexo.png" srcset="/img/loading.gif" alt=""><br>如上图就代表安装成功</p><h2 id="hexo初始化及本地预览"><a class="header-anchor" href="#hexo初始化及本地预览">¶</a>hexo初始化及本地预览</h2><p>完成hexo安装后，需要实现hexo初始化，并生成样例博客。在blog的文件夹下输入</p><pre><code>hexo init</code></pre><p>如果没有更改host，github下载速度较慢需要等待2分钟左右，若未报错则安装成功。安装成功后输入指令</p><pre><code>hexo s</code></pre><p>可以在 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 进行预览。</p><h2 id="hexo建立新博客"><a class="header-anchor" href="#hexo建立新博客">¶</a>hexo建立新博客</h2><p>在完成上述的初始化工作之后，可以建立自己的第一篇文章。输入命令：</p><pre><code>hexo n &quot;我的第一篇hexo博客&quot;</code></pre><p>双引号中的内容为博客名字，其存储位置在</p><blockquote><p>.\source_posts</p></blockquote><p>查看博客的保存位置<br><img src="07_set_first_artical.png" srcset="/img/loading.gif" alt=""><br>有生成的.md文件，对.md文件使用markdown进行编辑，保存（这里不再详细说明.md文件的编辑方法，可以用Typora工具、vim等），在blog文件夹下输入三条指令</p><pre><code>hexo cleanhexo ghexo s</code></pre><p><img src="08_generate_artical.png" srcset="/img/loading.gif" alt=""><br>可以在 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 端口查看生成效果。</p><h1>部署至<a href="https://github.com/" target="_blank" rel="noopener">GitHub<i class="fab  fa-github"></i></a></h1><h2 id="建立git仓库并安装git插件"><a class="header-anchor" href="#建立git仓库并安装git插件">¶</a>建立Git仓库并安装Git插件</h2><p>在自己的github账户下建立一个repository输入名字，这里需要注意你的repository名字必须是 <strong>[账户名].github.io</strong><br>安装git插件，在power客户端下输入指令：</p><pre><code>cnpm install --save hexo-deployer-git</code></pre><p>安装成功，提示如下：<br><img src="09_install_git_plugin.png" srcset="/img/loading.gif" alt=""></p><h2 id="设置配置文件"><a class="header-anchor" href="#设置配置文件">¶</a>设置配置文件</h2><p>部署到github远端需要修改hexo文件下的 _config.yml 文件，打开文件找到deploy位置<br><img src="10_git_set_position.png" srcset="/img/loading.gif" alt=""><br>修改类型属性(type)，添加两个属性 **repo和 branch **<br><img src="11_edit_repo.png" srcset="/img/loading.gif" alt=""><br>其中repo属性对应git地址，branch对应分支选项。</p><h2 id="远端部署"><a class="header-anchor" href="#远端部署">¶</a>远端部署</h2><p>修改_config.yml文件完成，需要将本地的博客部署到github上，使用命令</p><pre><code>hexo d</code></pre><p><img src="12_remote_deploy_hexo.png" srcset="/img/loading.gif" alt=""><br>等待…出现登录页，输入账号密码<br><img src="13_login.png" srcset="/img/loading.gif" alt=""><br>部署完成<br><img src="14_complete.png" srcset="/img/loading.gif" alt=""></p><h1>主题美化</h1><h2 id="主题下载"><a class="header-anchor" href="#主题下载">¶</a>主题下载</h2><p>hexo自带的主题为landspace，主题样式可以更改，这里选择下载yilia主题。在blog文件夹下输入命令：</p><pre><code>git colne https://github.com/litten/hexo-theme-yilia .\theme\yilia</code></pre><p>其中 网址为下载地址，网址后的路径为主题的存储位置。下载完成如下：<br><img src="15_download_yilia_theme.png" srcset="/img/loading.gif" alt=""><br>进入theme文件夹下，查看主题是否存储完成：<br><img src="16_theme_location.png" srcset="/img/loading.gif" alt=""></p><h2 id="更改主题"><a class="header-anchor" href="#更改主题">¶</a>更改主题</h2><p>下载完成后需要修改blog文件夹下的_config.yml文件，打开找到 <strong>theme</strong>属性<br><img src="17_set_theme.png" srcset="/img/loading.gif" alt=""></p><p>若未更改过主题，则显示为<strong>theme:landspace</strong>, landspace为主题名称，将其修改为 <strong>theme:yilia</strong>，在窗口输入三行指令在本地查看修改情况：</p><pre><code>hexo cleanhexo ghexo s</code></pre><p>若未出错，可以将其推向github，输入指令 ：</p><pre><code>hexo d</code></pre><h1>遇到的错误</h1><p>在hexo初始化时遇到一些小错误，输入初始化指令<strong>hexo init</strong>，出现错误结果如下：<br><img src="04_hexo_init_error.png" srcset="/img/loading.gif" alt=""></p><p>按照错误提示输入 <strong>npm install</strong> 仍报错<br><img src="05_input_npm_install_still_error.png" srcset="/img/loading.gif" alt=""></p><p>考虑到可能是连不上服务器所导致的，所以选择输入指令<strong>cnpm install</strong><br><img src="06_input_cnpm_install_solve_the_problem.png" srcset="/img/loading.gif" alt=""><br>问题解决</p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo的安装使用及Github部署</title>
    <link href="undefined2019/11/17/Hexo%E5%8D%9A%E5%AE%A2%E7%BC%96%E5%86%99%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <url>2019/11/17/Hexo%E5%8D%9A%E5%AE%A2%E7%BC%96%E5%86%99%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p><font color="#DC143C ">  <strong>本文用来不定时更新</strong> </font></p><a id="more"></a><h1>文档加载图片</h1><h2 id="markdown语法加载"><a class="header-anchor" href="#markdown语法加载">¶</a>markdown语法加载</h2><ol><li>找到hexo下的 _config.yml 文件，本机的存储位置</li></ol><pre><code> D:\00 DATA\08 HEXO blog\blog\ _config.yml</code></pre><ol start="2"><li>找到 post_asset_folder 属性，将其改为 true</li></ol><pre><code> post_asset_folder: true </code></pre><ol start="3"><li>使用指令</li></ol><pre><code> hexo n &quot;博客文章的名字&quot;</code></pre><p>新建一个博客，在路径</p><pre><code> \source\_posts </code></pre><p>下生成两个文件，分别为.md文件和其同名文件夹，将需要放在文章中的图片拷贝在同名文件夹中</p><ol start="4"><li>在.md文件中使用以下代码添加图片</li></ol><pre><code class="language-markdown">![图片描述](图片名称) </code></pre><p>上述的图片名称 可以直接写出图片的名称及类型，在文章中就可以正常显示。</p><h2 id="官方加载"><a class="header-anchor" href="#官方加载">¶</a>官方加载</h2><p>markdown语法加载图像的方式，在博客首页无法正常显示。所以这里给出另一种加载图像的方式，来解决上述问题。<br><a href="https://hexo.io/zh-cn/docs/asset-folders" target="_blank" rel="noopener">官网文档</a>给出的标签插件方法加载图片，仍按照上述1~3步骤来配置，第4部在编写.md文件时，插入图像语法修改为：</p><pre><code>{% asset_img 图像名.图像类型 图像名称 %}</code></pre><p>上述的加载方式在博客首页和文章内部都可以正常显示。</p><h1>修改博客背景</h1><p>修改文件 post.styl,存储位置</p><blockquote><p>D:\00 DATA\08 HEXO blog\blog\themes\next\source\css_common\components\post\post.styl</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>